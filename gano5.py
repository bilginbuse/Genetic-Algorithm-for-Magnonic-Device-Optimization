# -*- coding: utf-8 -*-
"""gano.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1896m9_MPmDi3iytb91Ot2obsPlBGWF0J
"""

# Run the code in Google Colab


def run_mumax3(script, name, verbose=False):
    """ Executes a mumax3 script and convert ovf files to numpy files
    
    Parameters
    ----------
      script:  string containing the mumax3 input script
      name:    name of the simulation (this will be the name of the script and output dir)
      verbose: print stdout of mumax3 when it is finished
    """
    
    from subprocess import run, PIPE, STDOUT
    from os import path

    scriptfile = name + ".txt" 
    outputdir  = name + ".out"

    # write the input script in scriptfile
    with open(scriptfile, 'w' ) as f:
        f.write(script)
    
    # call mumax3 to execute this script
    p = run(["mumax3","-f",scriptfile], stdout=PIPE, stderr=STDOUT)
    if verbose or p.returncode != 0:
        print(p.stdout.decode('UTF-8'))
        
    if path.exists(outputdir + "/table.txt"):
        table = read_mumax3_table(outputdir + "/table.txt")
    else:
        table = None
        
    fields = read_mumax3_ovffiles(outputdir)
    
    return table, fields

def read_mumax3_table(filename):
    """Puts the mumax3 output table in a pandas dataframe"""

    from pandas import read_table
    
    table = read_table(filename)
    table.columns = ' '.join(table.columns).split()[1::2]
    
    return table

def read_mumax3_ovffiles(outputdir):
    """Load all ovffiles in outputdir into a dictionary of numpy arrays 
    with the ovffilename (without extension) as key"""
    
    from subprocess import run, PIPE, STDOUT
    from glob import glob
    from os import path
    from numpy import load

    # convert all ovf files in the output directory to numpy files
    p = run(["mumax3-convert","-numpy",outputdir+"/*.ovf"], stdout=PIPE, stderr=STDOUT)
    if p.returncode != 0:
        print(p.stdout.decode('UTF-8'))

    # read the numpy files (the converted ovf files)
    fields = {}
    for npyfile in glob(outputdir+"/*.npy"):
        key = path.splitext(path.basename(npyfile))[0]
        fields[key] = load(npyfile)
    
    return fields

def run_mumax3(script, name, verbose=False):
    """ Executes a mumax3 script and convert ovf files to numpy files
    
    Parameters
    ----------
      script:  string containing the mumax3 input script
      name:    name of the simulation (this will be the name of the script and output dir)
      verbose: print stdout of mumax3 when it is finished
    """
    
    from subprocess import run, PIPE, STDOUT
    from os import path

    scriptfile = name + ".txt" 
    outputdir  = name + ".out"

    # write the input script in scriptfile
    with open(scriptfile, 'w' ) as f:
        f.write(script)
    
    # call mumax3 to execute this script
    p = run(["mumax3","-f",scriptfile], stdout=PIPE, stderr=STDOUT)
    if verbose or p.returncode != 0:
        print(p.stdout.decode('UTF-8'))
        
    if path.exists(outputdir + "/table.txt"):
        table = read_mumax3_table(outputdir + "/table.txt")
    else:
        table = None
        
    fields = read_mumax3_ovffiles(outputdir)
    
    return table, fields

import numpy as np
import random
import sys
import typing as t
import warnings
import copy
import time
import pandas as pd

def mumax_sim(ga_matrix: np.ndarray, f1, f2):
  script=f"""
Nx := 128
Ny := 64
c := 5e-9
SetGridsize(Nx, Ny, 1)
SetCellsize(c, c, 4*c)
//SetPBC(5,0,0)

// YIG Materials
Msat = 1.4e6
Aex = 3.5e-12
Ku1 = 0

// Define the waveguide

// Column 1
wg_f1 := rect(80e-9, 30e-9).transl(-50e-9, -35e-9, 0)
wg_f2 := rect(80e-9, 30e-9).transl(-50e-9, 35e-9, 0)
wg_l := rect(100e-9, 30e-9).transl(140e-9, 0, 0)

pxl1 := rect({ga_matrix[0]}*10e-9, {ga_matrix[0]}*10e-9).transl(-5e-9, 45e-9, 0)
pxl2 := rect({ga_matrix[1]}*10e-9, {ga_matrix[1]}*10e-9).transl(-5e-9, 35e-9, 0)
pxl3 := rect({ga_matrix[2]}*10e-9, {ga_matrix[2]}*10e-9).transl(-5e-9, 25e-9, 0)
pxl4 := rect({ga_matrix[3]}*10e-9, {ga_matrix[3]}*10e-9).transl(-5e-9, 15e-9, 0)
pxl5 := rect({ga_matrix[4]}*10e-9, {ga_matrix[4]}*10e-9).transl(-5e-9, 5e-9, 0)
pxl6 := rect({ga_matrix[5]}*10e-9, {ga_matrix[5]}*10e-9).transl(-5e-9, -5e-9, 0)
pxl7 := rect({ga_matrix[6]}*10e-9, {ga_matrix[6]}*10e-9).transl(-5e-9, -15e-9, 0)
pxl8 := rect({ga_matrix[7]}*10e-9, {ga_matrix[7]}*10e-9).transl(-5e-9, -25e-9, 0)
pxl9 := rect({ga_matrix[8]}*10e-9, {ga_matrix[8]}*10e-9).transl(-5e-9, -35e-9, 0)
pxl10 := rect({ga_matrix[9]}*10e-9, {ga_matrix[9]}*10e-9).transl(-5e-9, -45e-9, 0)
cl1 := pxl1.add(pxl2).add(pxl3).add(pxl4).add(pxl5).add(pxl6).add(pxl7).add(pxl8).add(pxl9).add(pxl10)

// Column 2
pxl11 := rect({ga_matrix[10]}*10e-9, {ga_matrix[10]}*10e-9).transl(5e-9, 45e-9, 0)
pxl12 := rect({ga_matrix[11]}*10e-9, {ga_matrix[11]}*10e-9).transl(5e-9, 35e-9, 0)
pxl13 := rect({ga_matrix[12]}*10e-9, {ga_matrix[12]}*10e-9).transl(5e-9, 25e-9, 0)
pxl14 := rect({ga_matrix[13]}*10e-9, {ga_matrix[13]}*10e-9).transl(5e-9, 15e-9, 0)
pxl15 := rect({ga_matrix[14]}*10e-9, {ga_matrix[14]}*10e-9).transl(5e-9, 5e-9, 0)
pxl16 := rect({ga_matrix[15]}*10e-9, {ga_matrix[15]}*10e-9).transl(5e-9, -5e-9, 0)
pxl17 := rect({ga_matrix[16]}*10e-9, {ga_matrix[16]}*10e-9).transl(5e-9, -15e-9, 0)
pxl18 := rect({ga_matrix[17]}*10e-9, {ga_matrix[17]}*10e-9).transl(5e-9, -25e-9, 0)
pxl19 := rect({ga_matrix[18]}*10e-9, {ga_matrix[18]}*10e-9).transl(5e-9, -35e-9, 0)
pxl20 := rect({ga_matrix[19]}*10e-9, {ga_matrix[19]}*10e-9).transl(5e-9, -45e-9, 0)
cl2 := pxl11.add(pxl12).add(pxl13).add(pxl14).add(pxl15).add(pxl16).add(pxl17).add(pxl18).add(pxl19).add(pxl20)

// Column 3
pxl21 := rect({ga_matrix[20]}*10e-9, {ga_matrix[20]}*10e-9).transl(15e-9, 45e-9, 0)
pxl22 := rect({ga_matrix[21]}*10e-9, {ga_matrix[21]}*10e-9).transl(15e-9, 35e-9, 0)
pxl23 := rect({ga_matrix[22]}*10e-9, {ga_matrix[22]}*10e-9).transl(15e-9, 25e-9, 0)
pxl24 := rect({ga_matrix[23]}*10e-9, {ga_matrix[23]}*10e-9).transl(15e-9, 15e-9, 0)
pxl25 := rect({ga_matrix[24]}*10e-9, {ga_matrix[24]}*10e-9).transl(15e-9, 5e-9, 0)
pxl26 := rect({ga_matrix[25]}*10e-9, {ga_matrix[25]}*10e-9).transl(15e-9, -5e-9, 0)
pxl27 := rect({ga_matrix[26]}*10e-9, {ga_matrix[26]}*10e-9).transl(15e-9, -15e-9, 0)
pxl28 := rect({ga_matrix[27]}*10e-9, {ga_matrix[27]}*10e-9).transl(15e-9, -25e-9, 0)
pxl29 := rect({ga_matrix[28]}*10e-9, {ga_matrix[28]}*10e-9).transl(15e-9, -35e-9, 0)
pxl30 := rect({ga_matrix[29]}*10e-9, {ga_matrix[29]}*10e-9).transl(15e-9, -45e-9, 0)
cl3 := pxl21.add(pxl22).add(pxl23).add(pxl24).add(pxl25).add(pxl26).add(pxl27).add(pxl28).add(pxl29).add(pxl30)

// Column 4
pxl31 := rect({ga_matrix[30]}*10e-9, {ga_matrix[30]}*10e-9).transl(25e-9, 45e-9, 0)
pxl32 := rect({ga_matrix[31]}*10e-9, {ga_matrix[31]}*10e-9).transl(25e-9, 35e-9, 0)
pxl33 := rect({ga_matrix[32]}*10e-9, {ga_matrix[32]}*10e-9).transl(25e-9, 25e-9, 0)
pxl34 := rect({ga_matrix[33]}*10e-9, {ga_matrix[33]}*10e-9).transl(25e-9, 15e-9, 0)
pxl35 := rect({ga_matrix[34]}*10e-9, {ga_matrix[34]}*10e-9).transl(25e-9, 5e-9, 0)
pxl36 := rect({ga_matrix[35]}*10e-9, {ga_matrix[35]}*10e-9).transl(25e-9, -5e-9, 0)
pxl37 := rect({ga_matrix[36]}*10e-9, {ga_matrix[36]}*10e-9).transl(25e-9, -15e-9, 0)
pxl38 := rect({ga_matrix[37]}*10e-9, {ga_matrix[37]}*10e-9).transl(25e-9, -25e-9, 0)
pxl39 := rect({ga_matrix[38]}*10e-9, {ga_matrix[38]}*10e-9).transl(25e-9, -35e-9, 0)
pxl40 := rect({ga_matrix[39]}*10e-9, {ga_matrix[39]}*10e-9).transl(25e-9, -45e-9, 0)
cl4 := pxl31.add(pxl32).add(pxl33).add(pxl34).add(pxl35).add(pxl36).add(pxl37).add(pxl38).add(pxl39).add(pxl40)

// Column 5
pxl41 := rect({ga_matrix[40]}*10e-9, {ga_matrix[40]}*10e-9).transl(35e-9, 45e-9, 0)
pxl42 := rect({ga_matrix[41]}*10e-9, {ga_matrix[41]}*10e-9).transl(35e-9, 35e-9, 0)
pxl43 := rect({ga_matrix[42]}*10e-9, {ga_matrix[42]}*10e-9).transl(35e-9, 25e-9, 0)
pxl44 := rect({ga_matrix[43]}*10e-9, {ga_matrix[43]}*10e-9).transl(35e-9, 15e-9, 0)
pxl45 := rect({ga_matrix[44]}*10e-9, {ga_matrix[44]}*10e-9).transl(35e-9, 5e-9, 0)
pxl46 := rect({ga_matrix[45]}*10e-9, {ga_matrix[45]}*10e-9).transl(35e-9, -5e-9, 0)
pxl47 := rect({ga_matrix[46]}*10e-9, {ga_matrix[46]}*10e-9).transl(35e-9, -15e-9, 0)
pxl48 := rect({ga_matrix[47]}*10e-9, {ga_matrix[47]}*10e-9).transl(35e-9, -25e-9, 0)
pxl49 := rect({ga_matrix[48]}*10e-9, {ga_matrix[48]}*10e-9).transl(35e-9, -35e-9, 0)
pxl50 := rect({ga_matrix[49]}*10e-9, {ga_matrix[49]}*10e-9).transl(35e-9, -45e-9, 0)
cl5 := pxl41.add(pxl42).add(pxl43).add(pxl44).add(pxl45).add(pxl46).add(pxl47).add(pxl48).add(pxl49).add(pxl50)

// Column 6
pxl51 := rect({ga_matrix[50]}*10e-9, {ga_matrix[50]}*10e-9).transl(45e-9, 45e-9, 0)
pxl52 := rect({ga_matrix[51]}*10e-9, {ga_matrix[51]}*10e-9).transl(45e-9, 35e-9, 0)
pxl53 := rect({ga_matrix[52]}*10e-9, {ga_matrix[52]}*10e-9).transl(45e-9, 25e-9, 0)
pxl54 := rect({ga_matrix[53]}*10e-9, {ga_matrix[53]}*10e-9).transl(45e-9, 15e-9, 0)
pxl55 := rect({ga_matrix[54]}*10e-9, {ga_matrix[54]}*10e-9).transl(45e-9, 5e-9, 0)
pxl56 := rect({ga_matrix[55]}*10e-9, {ga_matrix[55]}*10e-9).transl(45e-9, -5e-9, 0)
pxl57 := rect({ga_matrix[56]}*10e-9, {ga_matrix[56]}*10e-9).transl(45e-9, -15e-9, 0)
pxl58 := rect({ga_matrix[57]}*10e-9, {ga_matrix[57]}*10e-9).transl(45e-9, -25e-9, 0)
pxl59 := rect({ga_matrix[58]}*10e-9, {ga_matrix[58]}*10e-9).transl(45e-9, -35e-9, 0)
pxl60 := rect({ga_matrix[59]}*10e-9, {ga_matrix[59]}*10e-9).transl(45e-9, -45e-9, 0)
cl6 := pxl51.add(pxl52).add(pxl53).add(pxl54).add(pxl55).add(pxl56).add(pxl57).add(pxl58).add(pxl59).add(pxl60)

// Column 7
pxl61 := rect({ga_matrix[60]}*10e-9, {ga_matrix[60]}*10e-9).transl(55e-9, 45e-9, 0)
pxl62 := rect({ga_matrix[61]}*10e-9, {ga_matrix[61]}*10e-9).transl(55e-9, 35e-9, 0)
pxl63 := rect({ga_matrix[62]}*10e-9, {ga_matrix[62]}*10e-9).transl(55e-9, 25e-9, 0)
pxl64 := rect({ga_matrix[63]}*10e-9, {ga_matrix[63]}*10e-9).transl(55e-9, 15e-9, 0)
pxl65 := rect({ga_matrix[64]}*10e-9, {ga_matrix[64]}*10e-9).transl(55e-9, 5e-9, 0)
pxl66 := rect({ga_matrix[65]}*10e-9, {ga_matrix[65]}*10e-9).transl(55e-9, -5e-9, 0)
pxl67 := rect({ga_matrix[66]}*10e-9, {ga_matrix[66]}*10e-9).transl(55e-9, -15e-9, 0)
pxl68 := rect({ga_matrix[67]}*10e-9, {ga_matrix[67]}*10e-9).transl(55e-9, -25e-9, 0)
pxl69 := rect({ga_matrix[68]}*10e-9, {ga_matrix[68]}*10e-9).transl(55e-9, -35e-9, 0)
pxl70 := rect({ga_matrix[69]}*10e-9, {ga_matrix[69]}*10e-9).transl(55e-9, -45e-9, 0)
cl7 := pxl61.add(pxl62).add(pxl63).add(pxl64).add(pxl65).add(pxl66).add(pxl67).add(pxl68).add(pxl69).add(pxl70)

// Column 8
pxl71 := rect({ga_matrix[70]}*10e-9, {ga_matrix[70]}*10e-9).transl(65e-9, 45e-9, 0)
pxl72 := rect({ga_matrix[71]}*10e-9, {ga_matrix[71]}*10e-9).transl(65e-9, 35e-9, 0)
pxl73 := rect({ga_matrix[72]}*10e-9, {ga_matrix[72]}*10e-9).transl(65e-9, 25e-9, 0)
pxl74 := rect({ga_matrix[73]}*10e-9, {ga_matrix[73]}*10e-9).transl(65e-9, 15e-9, 0)
pxl75 := rect({ga_matrix[74]}*10e-9, {ga_matrix[74]}*10e-9).transl(65e-9, 5e-9, 0)
pxl76 := rect({ga_matrix[75]}*10e-9, {ga_matrix[75]}*10e-9).transl(65e-9, -5e-9, 0)
pxl77 := rect({ga_matrix[76]}*10e-9, {ga_matrix[76]}*10e-9).transl(65e-9, -15e-9, 0)
pxl78 := rect({ga_matrix[77]}*10e-9, {ga_matrix[77]}*10e-9).transl(65e-9, -25e-9, 0)
pxl79 := rect({ga_matrix[78]}*10e-9, {ga_matrix[78]}*10e-9).transl(65e-9, -35e-9, 0)
pxl80 := rect({ga_matrix[79]}*10e-9, {ga_matrix[79]}*10e-9).transl(65e-9, -45e-9, 0)
cl8 := pxl71.add(pxl72).add(pxl73).add(pxl74).add(pxl75).add(pxl76).add(pxl77).add(pxl78).add(pxl79).add(pxl80)

// Column 9
pxl81 := rect({ga_matrix[80]}*10e-9, {ga_matrix[80]}*10e-9).transl(75e-9, 45e-9, 0)
pxl82 := rect({ga_matrix[81]}*10e-9, {ga_matrix[81]}*10e-9).transl(75e-9, 35e-9, 0)
pxl83 := rect({ga_matrix[82]}*10e-9, {ga_matrix[82]}*10e-9).transl(75e-9, 25e-9, 0)
pxl84 := rect({ga_matrix[83]}*10e-9, {ga_matrix[83]}*10e-9).transl(75e-9, 15e-9, 0)
pxl85 := rect({ga_matrix[84]}*10e-9, {ga_matrix[84]}*10e-9).transl(75e-9, 5e-9, 0)
pxl86 := rect({ga_matrix[85]}*10e-9, {ga_matrix[85]}*10e-9).transl(75e-9, -5e-9, 0)
pxl87 := rect({ga_matrix[86]}*10e-9, {ga_matrix[86]}*10e-9).transl(75e-9, -15e-9, 0)
pxl88 := rect({ga_matrix[87]}*10e-9, {ga_matrix[87]}*10e-9).transl(75e-9, -25e-9, 0)
pxl89 := rect({ga_matrix[88]}*10e-9, {ga_matrix[88]}*10e-9).transl(75e-9, -35e-9, 0)
pxl90 := rect({ga_matrix[89]}*10e-9, {ga_matrix[89]}*10e-9).transl(75e-9, -45e-9, 0)
cl9 := pxl81.add(pxl82).add(pxl83).add(pxl84).add(pxl85).add(pxl86).add(pxl87).add(pxl88).add(pxl89).add(pxl90)

// Column 10
pxl91 := rect({ga_matrix[90]}*10e-9, {ga_matrix[90]}*10e-9).transl(85e-9, 45e-9, 0)
pxl92 := rect({ga_matrix[91]}*10e-9, {ga_matrix[91]}*10e-9).transl(85e-9, 35e-9, 0)
pxl93 := rect({ga_matrix[92]}*10e-9, {ga_matrix[92]}*10e-9).transl(85e-9, 25e-9, 0)
pxl94 := rect({ga_matrix[93]}*10e-9, {ga_matrix[93]}*10e-9).transl(85e-9, 15e-9, 0)
pxl95 := rect({ga_matrix[94]}*10e-9, {ga_matrix[94]}*10e-9).transl(85e-9, 5e-9, 0)
pxl96 := rect({ga_matrix[95]}*10e-9, {ga_matrix[95]}*10e-9).transl(85e-9, -5e-9, 0)
pxl97 := rect({ga_matrix[96]}*10e-9, {ga_matrix[96]}*10e-9).transl(85e-9, -15e-9, 0)
pxl98 := rect({ga_matrix[97]}*10e-9, {ga_matrix[97]}*10e-9).transl(85e-9, -25e-9, 0)
pxl99 := rect({ga_matrix[98]}*10e-9, {ga_matrix[98]}*10e-9).transl(85e-9, -35e-9, 0)
pxl100 := rect({ga_matrix[99]}*10e-9, {ga_matrix[99]}*10e-9).transl(85e-9, -45e-9, 0)
cl10 := pxl91.add(pxl92).add(pxl93).add(pxl94).add(pxl95).add(pxl96).add(pxl97).add(pxl98).add(pxl99).add(pxl100)



wg := wg_f1.add(wg_f2).add(cl1).add(cl2).add(cl3).add(cl4).add(cl5).add(cl6).add(cl7).add(cl8).add(cl9).add(cl10).add(wg_l)
setgeom(wg)
//saveas(geom, "wg")

// Varying alpha

defregion(1, xrange(-inf, 182e-9))  // 1st column
defregion(2, xrange(182e-9, 183e-9)) // 2nd column
defregion(3, xrange(183e-9, 184e-9))  // 3rd column
defregion(4, xrange(184e-9, 185e-9)) // 4th column
defregion(5, xrange(185e-9, 186e-9))  // 5th column
defregion(6, xrange(186e-9, 187e-9)) // 6th column
defregion(7, xrange(187e-9, 188e-9))  // 7th column
defregion(8, xrange(188e-9, 189e-9)) // 8th column
defregion(9, xrange(189e-9, 190e-9))  // 9th column
save(regions)

alpha.setregion(1, 2e-3)
alpha.setregion(2, 6.43e-2)
alpha.setregion(3, 12.65e-2)
alpha.setregion(4, 18.88e-2)
alpha.setregion(5, 25.1e-2)
alpha.setregion(6, 31.33e-2)
alpha.setregion(7, 37.55e-2)
alpha.setregion(8, 45.77e-2)
alpha.setregion(9, 0.5)


// Magnetic field

Bz := 200e-3
B_ext = vector(0,0,Bz)
defregion(1,rect(20e-9, 30e-9).transl(-50e-9, -35e-9, 0))
defregion(2,rect(20e-9, 30e-9).transl(-50e-9, 35e-9, 0))

B_ext.setregion(1, vector(0.1e-3 * sinc( 2*pi*{f1}*(t-50e-9/2)), 0, Bz))
B_ext.setregion(2, vector(0.1e-3 * sinc( 2*pi*{f2}*(t-50e-9/2)), 0, Bz))

m = uniform(0,0,1) 
minimize()
//m = randomMag()
//relax() 
autosave(m,50e-12)
tableautosave(50e-12)
run(50e-9)
"""
  table, fields = run_mumax3(script,"skyrmion")
  return table, fields
#array= np.ones((1,100)).reshape(100)
#table_2, fields_2 = mumax_sim(ga_matrix = array, f = 18e9)



## Crossover iteration'da bir problem var! Ana kodda çalışma problemi yok
## Crossover - elitism - mutation oranlarını birbirleri ile korele hale getirmek gerek
## Database devreye sokulacak
## Farklı bir programdan input alınırken bekleme süresi nasıl olacak?

#!/usr/bin/env python3
#
# Genetic Algorithm: A Comprehensive Genetic Algorithm in Python, for nanophotonic modelling.
# 
# Copyright © 2020-2021 by Buse Bilgin
#
# Permission is granted to anyone to use this software, in source or object code form,
# on any computer system, and to modify, compile, decompile, run, and redistribute it
# to anyone else, subject to the following restrictions:
#
#   - The author makes no warranty of any kind, either expressed or implied, about the
#     suitability of this software for any purpose.
#   - The author accepts no liability of any kind for damages or other consequences of
#     the use of this software, even if they arise from defects in the software.
#   - The origin of this software must not be misrepresented, either by explicit claim
#     or by omission.
#
# Altered versions must be plainly marked as such, and must not be misrepresented as
# being the original software. Altered versions may be distributed in packages under
# other licenses (such as the GNU license).
#
# If you find this software useful, it would be nice if you let me (bebrem18@ku.edu.tr)
# know about it, and nicer still if you send me modifications that you are willing to
# share. However, you are not required to do so.
#
# uncomment this is the Pandas library has not been installed yet.
# !pip3 install pandas

import numpy as np
import random
import sys
import typing as t
import warnings
import copy
import time
import pandas as pd

def fitness_function(array: np.ndarray):
  array = array.reshape(100)
  f1 = 16e9 #0 
  f2 = 18e9 #1
  table_1, fields_1 = mumax_sim(ga_matrix = array, f1 = f1, f2 = f2) # i_0 = 0 , i_1 = 0, o = 0

  fieldskey = ['m000087', 'm000518', 'm000144', 'm000071', 'm000057', 'm000324', 'm000041', 'm000295', 'm000035', 'm000272', 'm000102', 'm000945', 'm000318', 'm000061', 
  'm000576', 'm000281', 'm000002', 'm000373', 'm000677', 'm000631', 'm000998', 'm000178', 'm000754', 'm000090', 'm000983', 'm000924', 'm000142', 'm000738', 'm000288', 'm000807',
'm000609', 'm000731', 'm000267', 'm000245', 'm000726', 'm000707', 'm000113', 'm000725', 'm000634', 'm000099', 'm000698', 'm000700', 'm000914', 'm000593', 'm000775', 'm000871', 
'm000501', 'm000997', 'm000865', 'm000608', 'm000861', 'm000255', 'm000549', 'm000566', 'm000254', 'm000811', 'm000535', 'm000136', 'm000032', 'm000316', 'm000079', 'm000962',
 'm000505', 'm000415', 'm000798', 'm000110', 'm000047', 'm000125', 'm000140', 'm000283', 'm000089', 'm000712', 'm000246', 'm000440', 'm000574', 'm000169', 'm000757', 'm000141', 'm000081', 'm000296', 'm000940', 'm000627', 'm000606', 'm000804', 'm000348', 'm000652', 'm000212', 'm000993', 'm000162', 'm000690', 'm000669', 'm000635', 'm000662', 'm000953', 'm000849', 'm000558', 'm000243', 'm000599', 'm000104', 'm000191', 'm000145', 'm000596', 'm000604', 'm000412', 'm000455', 'm000744', 'm000109', 'm000251', 'm000084', 'm000301', 'm000934', 'm000866', 'm000847', 'm000595', 'm000944', 'm000031', 'm000638', 'm000781', 'm000727', 'm000801', 'm000477', 'm000590', 'm000026', 'm000199', 'm000497', 'm000052', 'm000613', 'm000963', 'm000815', 'm000478', 'm000392', 'm000633', 'm000126', 'm000143', 'm000673', 'm000185', 'm000300', 'm000020', 'm000290', 'm000219', 'm000892', 'm000896', 'm000976', 'm000470', 'm000879', 'm000421', 'm000981', 'm000832', 'm000231', 'm000784', 'm000379', 'm000909', 'm000913', 'm000000', 'm000530', 'm000425', 'm000224', 'm000649', 'm000055', 'm000405', 'm000573', 'm000805', 'm000025', 'm000921', 'm000598', 'm000305', 'm000265', 'm000954', 'm000358', 'm000230', 'm000917', 'm000010', 'm000597', 'm000752', 'm000762', 'm000898', 'm000581', 'm000586', 'm000769', 'm000645', 'm000936', 'm000691', 'm000459', 'm000551', 'm000570', 'm000473', 'm000076', 'm000332', 'm000777', 'm000462', 'm000229', 'm000008', 'm000389', 'm000488', 'm000623', 'm000678', 'm000376', 'm000474', 'm000794', 'm000680', 'm000258', 'm000911', 'm000605', 'm000895', 'm000878', 'm000394', 'm000317', 'm000986', 'm000115', 'm000977', 'm000257', 'm000571', 'm000451', 'm000659', 'm000875', 'm000252', 'm000857', 'm000538', 'm000221', 'm000036', 'm000356', 'm000689', 'm000806', 'm000927', 'm000562', 'm000225', 'm000820', 'm000974', 'm000273', 'm000482', 'm000108', 'm000227', 'm000736', 'm000876', 'm000134', 'm000363', 'm000130', 'm000525', 'm000555', 'm000952', 'm000205', 'm000422', 'm000852', 'm000066', 'm000202', 'm000119', 'm000361', 'm000366', 'm000369', 'm000884', 'm000569', 'm000309', 'm000122', 'm000306', 'm000542', 'm000038', 'm000193', 'm000988', 'm000796', 'm000885', 'm000776', 'm000965', 'm000500', 'm000862', 'm000584', 'm000307', 'm000408', 'm000992', 'm000172', 'm000384', 'm000964', 'm000616', 'm000619', 'm000646', 'm000729', 'm000154', 'm000688', 'm000285', 'm000062', 'm000082', 'm000580', 'm000280', 'm000207', 'm000239', 'm000537', 'm000217', 'm000005', 'm000856', 'm000773', 'm000745', 'm000050', 'm000889', 'm000372', 'm000137', 'm000703', 'm000708', 'm000431', 'm000489', 'm000274', 'm000587', 'm000287', 'm000299', 'm000902', 'm000465', 'm000547', 'm000312', 'm000390', 'm000790', 'm000344', 'm000561', 'm000824', 'm000864', 'm000320', 'm000932', 'm000552', 'm000812', 'm000655', 'm000509', 'm000719', 'm000445', 'm000313', 'm000407', 'm000741', 'm000632', 'm000814', 'm000668', 'm000232', 'm000293', 'm000092', 'm000475', 'm000694', 'm000560', 'm000624', 'm000341', 'm000333', 'm000487', 'm000049', 'm000435', 'm000709', 'm000184', 'm000060', 'm000103', 'm000413', 'm000086', 'm000716', 'm000904', 'm000023', 'm000120', 'm000994', 'm000834', 'm000019', 'm000346', 'm000067', 'm000364', 'm000508', 'm000626', 'm000978', 'm000009', 'm000461', 'm000785', 'm000968', 'm000438', 'm000724', 'm000428', 'm000600', 'm000810', 'm000135', 'm000522', 'm000401', 'm000132', 'm000979', 'm000094', 'm000072', 'm000937', 'm000982', 'm000424', 'm000664', 'm000437', 'm000671', 'm000127', 'm000771', 'm000888', 'm000770', 'm000165', 'm000068', 'm000342', 'm000007', 'm000950', 'm000430', 'm000959', 'm000828', 'm000359', 'm000536', 'm000910', 'm000443', 'm000565', 'm000056', 'm000409', 'm000935', 'm000054', 'm000733', 'm000375', 'm000692', 'm000722', 'm000973', 'm000970', 'm000961', 'm000276', 'm000075', 'm000630', 'm000648', 'm000507', 'm000845', 'm000269', 'm000244', 'm000030', 'm000011', 'm000822', 'm000995', 'm000411', 'm000275', 'm000960', 'm000385', 'm000899', 'm000742', 'm000743', 'm000124', 'm000808', 'm000687', 'm000748', 'm000592', 'm000534', 'm000114', 'm000901', 'm000388', 'm000453', 'm000987', 'm000043', 'm000737', 'm000173', 'm000514', 'm000444', 'm000817', 'm000601', 'm000803', 'm000567', 'm000789', 'm000591', 'm000196', 'm000040', 'm000256', 'm000168',
  'm000155', 'm000151', 'm000209', 'm000302', 'm000620', 'm000693', 'm000951', 'm000617', 'm000644', 'm000164', 'm000427', 'm000330', 'm000946', 'm000213', 'm000656', 'm000710', 'm000266', 'm000628', 'm000800', 'm000637', 'm000665', 'm000544', 'm000753', 'm000933', 'm000682', 'm000763', 'm000818', 'm000463', 'm000835', 'm000684', 'm000006', 'm000739', 'm000073', 'm000263', 'm000323', 'm000195', 'm000304', 'm000419', 'm000423', 'm000399', 'm000564', 'm000210', 'm000161', 'm000368', 'm000093', 'm000353', 'm000464', 'm000133', 'm000402', 'm000450', 'm000869', 'm000371', 'm000989', 'm000486', 'm000294', 'm000676', 'm000091', 'm000223', 'm000398', 'm000335', 'm000018', 'm000802', 'm000069', 'm000118', 'm000051', 'm000498', 'm000147', 'm000740', 'm000797', 'm000128', 'm000014', 'm000730', 'm000181', 'm000396', 'm000779', 'm000720', 'm000756', 'm000354', 'm000319', 'm000867', 'm000292', 'm000454', 'm000585', 'm000096', 'm000355', 'm000495', 'm000083', 'm000397', 'm000705', 'm000991', 'm000496', 'm000192', 'm000471', 'm000697', 'm000027', 'm000420', 'm000919', 'm000643', 'm000148', 'm000166', 'm000674', 'm000930', 'm000282', 'm000117', 'm000449', 'm000208', 'm000153', 'm000432', 'm000177', 'm000838', 'm000380', 'm000755', 'm000189', 'm000837', 'm000291', 'm000201', 'm000594', 'm000194', 'm000259', 'm000751', 'm000466', 'm000329', 'm000315', 'm000447', 'm000484', 'm000734', 'm000490', 'm000378', 'm000699', 'm000374', 'm000503', 'm000972', 'm000433', 'm000839', 'm000660', 'm000906', 'm000352', 'm000510', 'm000479', 'm000823', 'm000543', 'm000999', 'm000887', 'm000111', 'm000416', 'm000260', 'm000095', 'm000948', 'm000017', 'm000337', 'm000347', 'm000485', 'm000894', 'm000249', 'm000842', 'm000048', 'm000550', 'm000696', 'm000215', 'm000494', 'm000236', 'm000391', 'm000870', 'm000325', 'm000327', 'm000088', 'm000468', 'm000338', 'm000183', 'm000460', 'm000098', 'm000881', 'm000863', 'm000528', 'm000237', 'm000928', 'm000780', 'm000053', 'm000242', 'm000182', 'm000406', 'm000685', 'm000829', 'm000873', 'm000289', 'm000663', 'm000813', 'm000667', 'm000618', 'm000721', 'm000799', 'm000795', 'm000957', 'm000650', 'm000540', 'm000238', 'm000582', 'm000107', 'm000045', 'm000658', 'm000557', 'm000718', 'm000735', 'm000926', 'm000024', 'm000519', 'm000929', 'm000129', 'm000717', 'm000653', 'm000240', 'm000197', 'm000713', 'm000472', 'm000683', 'm000176', 'm000170', 'm000568', 'm000846', 'm000764', 'm000923', 'm000893', 'm000349', 'm000426', 'm000553', 'm000661', 'm000890', 'm000670', 'm000326', 'm000529', 'm000220', 'm000533', 'm000228', 'm000966', 'm000532', 'm000859', 'm000395', 'm000469', 'm000666', 'm000851', 'm000467', 'm000793', 'm000848', 'm000844', 'm000334', 'm000400', 'm000625', 'm000657', 'm000942', 'm000850', 'm000226', 'm000575', 'm000843', 'm000247', 'm000872', 'm000809', 'm000943', 'm000732', 'm000765', 'm000641', 'm000360', 'm000286', 'm000925', 'm000491', 'm000880', 'm000855', 'm000303', 'm000483', 'm000615', 'm000021', 'm000611', 'm000711', 'm000826', 'm000271', 'm000100', 'm000331', 'm000362', 'm000513', 'm000198', 'm000203', 'm000766', 'm000403', 'm000774', 'm000386', 'm000672', 'm000629', 'm000578', 'm000695', 'm000990', 'm000439', 'm000159', 'm000984', 'm000003', 'm000772', 'm000675', 'm000222', 'm000971', 'm000572', 'm000264', 'm000417', 'm000767', 'm000393', 'm000106', 'm000827', 'm000268', 'm000149', 'm000171', 'm000916', 'm000792', 'm000321', 'm000704', 'm000723', 'm000908', 'm000167', 'm000760', 'm000583', 'm000891', 'm000523', 'm000044', 'm000034', 'm000750', 'm000211', 'm000654', 'm000175', 'm000915', 'm000788', 'm000042', 'm000322', 'm000418', 'm000298', 'm000548', 'm000746', 'm000980', 'm000279', 'm000112', 'm000328', 'm000492', 'm000200', 'm000493', 'm000131', 'm000897', 'm000517', 'm000037', 'm000382', 'm000157', 'm000874', 'm000816', 'm000905', 'm000821', 'm000787', 'm000602', 'm000015', 'm000448', 'm000039', 'm000350', 'm000996', 'm000883', 'm000253', 'm000840', 'm000116', 'm000481', 'm000186', 'm000877', 'm000531', 'm000636', 'm000046', 'm000188', 'm000336', 'm000476', 'm000903', 'm000429', 'm000545', 'm000958', 'm000504', 'm000458', 'm000064', 'm000297', 'm000920', 'm000261', 'm000004', 'm000216', 'm000941', 'm000345', 'm000527', 'm000515', 'm000686', 'm000782', 'm000310', 'm000204', 'm000833', 'm000377', 'm000610', 'm000502', 'm000074', 'm000791', 'm000365', 'm000603', 'm000918', 'm000969', 'm000702', 'm000778', 'm000841', 'm000728', 'm000868', 'm000758', 'm000101', 'm000340', 'm000521', 'm000831', 'm000614', 'm000956', 'm000097', 'm000681', 'm000647', 'm000975', 'm000442', 'm000012', 'm000241', 'm000511', 'm000146', 'm000248', 'm000158', 'm000985', 'm000588', 'm000524', 'm000452', 'm000706', 'm000747', 'm000640', 'm000138', 'm000150', 'm000642', 'm000499', 'm000233', 'm000520', 'm000825', 'm000858', 'm000714', 'm000886', 'm000152', 'm000058', 'm000786', 'm000607', 'm000284', 'm000414', 'm000085', 'm000013', 'm000589', 'm000381', 'm000383', 'm000160', 'm000214', 'm000105', 'm000077', 'm000029', 'm000063', 'm000367', 'm000768', 'm000218', 'm000206', 'm000446', 'm000270', 'm000947', 'm000357', 'm000506', 'm000541', 'm000577', 'm000612', 'm000308', 'm000234', 'm000410', 'm000900', 'm000621', 'm000163', 'm000516', 'm000065', 'm000539', 'm000351', 'm000190', 'm000370', 'm000180', 'm000187', 'm000783', 'm000860', 'm000262', 'm000028', 'm000749', 'm000250', 'm000949', 'm000922', 'm000078', 'm000579', 'm000179', 'm000639', 'm000343', 'm000836', 'm000080', 'm000854', 'm000882', 'm000563', 'm000434', 'm000059', 'm000311', 'm000526', 'm000679', 'm000387', 'm000622', 'm000016', 'm000314', 'm000123', 'm000436', 'm000001', 'm000938', 'm000404', 'm000830', 'm000457', 'm000955', 'm000480', 'm000121', 'm000033', 'm000853', 'm000759', 'm000907', 'm000554', 'm000278', 'm000235', 'm000546', 'm000022', 'm000761', 'm000651', 'm000931', 'm000819', 'm000967', 'm000912', 'm000939', 'm000070', 'm000139', 'm000339', 'm000156', 'm000701', 'm000174', 'm000559', 'm000556', 'm000456', 'm000441', 'm000277', 'm000715', 'm000512']

  m1 = np.stack([fields_1[key] for key in sorted(fieldskey)])

  dt1   = 1/(2*18e9)
  freq1   = np.linspace(0, 1/dt1,len(fieldskey))

  ## M1 
  # Select the y component and the (only) layer z=0
  my1 = m1[:,1,:,31,90]
  # Apply the FFT for every cell
  m1_fft = np.abs(np.fft.fft(my1, axis=0)).reshape(len(fieldskey))
  zero_out1 = np.interp(15e9, freq1,m1_fft)
  one_out1 = np.interp(16e9, freq1,m1_fft)
  zero_out2 = np.interp(17e9, freq1,m1_fft)
  one_out2 = np.interp(18e9, freq1,m1_fft)
  zero_out3 = np.interp(19e9, freq1,m1_fft)
  one_out3 = np.interp(20e9, freq1,m1_fft)
  

  obj = (1-zero_out1)*(one_out1)*(1-zero_out2)*(one_out2)*(1-zero_out3)*(one_out3)

  if (obj < 0):
    fitness = 0
  else:
    fitness = obj
  return fitness

class GeneticAlgorithm:
  """
  Runs the genetic algorithm for nanophotonic design.
  Constructor parameters:
    - population_size = number of individuals.
    - ga_type = string of the selected GA model.
    - individual_length = length of the chromosome.
    - fitness_function = function that returns a fitness score.
    - mutation_rate = rate of genes that will be mutated randomly.
    - elitism_rate = rate of best individuals that will be directly used in the next
                      generation.
    - termination_time = maximum number of iteration, i.e. if the algorithm could not
                      converge up to this iteration, the optimization will be terminated.
    - verbose = select True for printing the debug messages out.
    - initial_population = if nothing is defined, the population is randomly generatated, 
                      else predefined ("matrix") initial population used
  There are different GA types
  """

  def __init__(self, population_size: int, ga_type: str, individual_length: int, fitness_function, 
              mutation_rate: float = 0.1, elitism_rate: float = 0.1, termination_time: int = 10, verbosa: bool = False,
              initial_population = None, lower_limit: float = 0.0, upper_limit: float = 1.0, crossover_func: str = "two-point",
              xover_alpha: float = None, mutation_func: str = "uniform", selection_func: str = "tournament",
              tournament_size: int = 4, selection_rate: float = 0.6, gaussian_mu: float = None, gaussian_sigma: float = None,
              gaussian_indep_prob: float = None, fitness_scaling : str = 'norank', visualization_type: str = 'final', gen_lim: int = 100):

    self.population_size = population_size
    self.ga_type = ga_type
    self.individual_length = individual_length
    self.mutation_rate = mutation_rate
    self.elitism_rate = elitism_rate
    self.termination_time = termination_time
    self.verbosa = verbosa
    self.fitness_function = fitness_function
    self.initial_population = initial_population
    self.lower_limit = lower_limit
    self.upper_limit = upper_limit
    self.crossover_func = crossover_func
    self.xover_alpha = xover_alpha
    self.mutation_func = mutation_func
    self.selection_func = selection_func
    self.population = np.zeros((self.population_size, self.individual_length))
    self.tournament_size = tournament_size
    self.selection_rate = selection_rate
    self.fitness_values = np.zeros((self.population_size, self.individual_length))
    self.gaussian_mu = gaussian_mu
    self.gaussian_sigma = gaussian_sigma
    self.gaussian_indep_prob = gaussian_indep_prob
    self.fitness_scaling = fitness_scaling
    self.visualization_type = visualization_type
    self.fittest_ind = np.zeros((1,self.individual_length))
    self.worst_ind = np.zeros((1,self.individual_length))
    self.mean_ind = np.zeros((1,self.individual_length))
    self.best_generation = 0
    self.best_score = 0
    self.gen_lim = gen_lim
    self.selection_size = 0
    

  def individual_scale(self, ind):
    return ((ind - min(ind[0,:]))/(max(ind[0,:])-min(ind[0,:])) * (self.upper_limit - self.lower_limit) + self.lower_limit)
  

  def random_individual(self):
    return np.random.rand(1,self.individual_length)


  def in_pop(self) -> np.array:
    if self.initial_population == None:
      ind = np.array([self.individual_scale(self.random_individual()) for _ in range(self.population_size)])
      if self.ga_type == "binary":
        ind_initial = np.around(ind)
      else:
        ind_initial = ind
    else:
      ind_initial = np.tile(self.initial_population, (self.population_size, 1))
    return ind_initial
  

  def elitism(self, population: np.array) -> np.array:
    elitist = int(np.round(self.population_size * self.elitism_rate))
    sorted_index = np.argsort(self.fitness_value(population),axis=0)
    sorted_population = population[sorted_index,:]
    sorted_population = np.array(sorted_population[0:elitist,:]).reshape(elitist, self.individual_length)
    return sorted_population

  # crossover + elitism + RANDOMLY GENERATED = 1 olmalı (?) Şu an initial pop'a çok bağlı çünkü sadece crossover var
  def gen_pop(self, previous_pop: np.array) -> np.array:
    #fitness values of previous population
    fitness_values = self.fitness_value(previous_pop)
    print(fitness_values)
    # fitness scaling
    next_generation = self.elitism(previous_pop)
    if self.fitness_scaling == 'rank':
      rank_index = np.argsort(self.fitness_value(previous_pop[i,:]))
      scaled_pop = np.divide(previous_pop,rank_index) 
      rank_fitness = np.take_along_axis(scaled_pop,rank_index,axis=1)
    else:
      rank_fitness = fitness_values
    crossover_iter = iter(self.selection(previous_pop,rank_fitness))
    crossover_gen = [self.crossover(cross_individual, next(crossover_iter)) for cross_individual in crossover_iter]
    crossover_g = np.array(crossover_gen).reshape(self.selection_size,self.individual_length)
    mutated_gen = self.mutation(crossover_g)
    next_generation = np.append(next_generation, mutated_gen, axis=0)
    if int(np.round((self.population_size * self.elitism_rate + self.selection_size))) != self.population_size:
      remaining = int(np.round(self.population_size - (self.population_size * self.elitism_rate + self.selection_size)))
      remaining_ind = np.round(np.array([self.individual_scale(self.random_individual()) for _ in range(remaining)])).reshape(remaining, self.individual_length)
      next_generation = np.append(next_generation, remaining_ind, axis=0)
    return next_generation


  def fitness_value(self, population: np.array) -> np.array:
    return np.array([self.fitness_function(population[ind,:]) for ind in range(self.population_size)])


  def crossover(self, ind_a: np.array, ind_b: np.array) -> np.array:
    if self.crossover_func == "single-point":
      crossover_point = random.randint(1,self.individual_length)
      offspring_a = np.append(ind_a[:crossover_point], ind_b[crossover_point:])
      offspring_b = np.append(ind_b[:crossover_point], ind_a[crossover_point:])
      return np.array([offspring_a,offspring_b])
    elif self.crossover_func == "two-point":
      crossover_points = np.sort(np.random.randint(1,self.individual_length,2))
      offspring_a = np.concatenate((ind_a[:crossover_points[0]], ind_b[crossover_points[0]:crossover_points[1]], ind_a[crossover_points[1]:]))
      offspring_b = np.concatenate((ind_b[:crossover_points[0]], ind_a[crossover_points[0]:crossover_points[1]], ind_b[crossover_points[1]:]))
      return np.array([offspring_a,offspring_b])
    elif self.crossover_func == "uniform":
      crossover_points = np.random.rand(1,self.individual_length)
      for i in range(crossover_points.shape[1]):
        if crossover_points[i] < 0.5:
          tmp = ind_a[i]
          ind_a[i] = ind_b[i]
          ind_b[i] = temp
      return np.array([ind_a,ind_b])
    elif self.crossover_func == "arithmetic-recomb":
      offspring_a = ind_a * self.xover_alpha + (1 - self.xover_alpha) * ind_b
      offspring_b = ind_b * self.xover_alpha + (1 - self.xover_alpha) * ind_a
      return np.array([offspring_a,offspring_b])
    elif self.crossover_func == "blend":
      i1 = copy.deepcopy(ind_a)
      i2 = copy.deepcopy(ind_b)
      for i in range(self.individual_length):
        tmp_1 = min(i1[i],i2[i]) - self.xover_alpha * np.absolute(i2[i] - i1[i])
        tmp_2 = max(i1[i],i2[i]) - self.xover_alpha * np.absolute(i2[i] - i1[i])
        i1[i] = np.round(tmp_1 + np.random.rand() * (tmp_2 - tmp_1),2)
        i2[i] = np.round(tmp_1 + np.random.rand() * (tmp_2 - tmp_1),2)
      return np.array([i1,i2])


  def mutation(self, population: np.array) -> np.array:
    mut_ind = int(np.round(self.population_size * self.mutation_rate))
    if self.mutation_func == "uniform":
      for i in range(mut_ind):
        index = np.random.randint(1,self.selection_size)
        gene_mut = np.random.randint(1,self.individual_length)
        current_ind = population[index,:]
        if self.ga_type == 'binary':
          if current_ind[gene_mut] == 0:
            current_ind[gene_mut] = 1
          elif current_ind[gene_mut] == 1:
            current_ind[gene_mut] = 0
          population[index,:] = current_ind
        else:
          rnd_number = self.individual_scale(np.append([0,1],np.random.rand()))
          current_ind[gene_mut] = rnd_number[2]
          population[index,:] = current_ind
      return population
    elif self.mutation_func == "gaussian":
      for j in range(mut_ind):
        ind_size = self.population_size
        index = np.random.randint(1,self.population_size)
        current_ind = population[index,:]
        if not isinstance(self.gaussian_mu, Sequence):
          self.gaussian_mu = np.repeat(self.gaussian_mu, size)
        elif self.gaussian_mu.shape[1] < ind_size:
          raise IndexError("Gaussian variable of 'mu' must be at least the size of individual: %d < %d" % (self.gaussian_mu.shape[1], ind_size))
        if not isinstance(self.gaussian_sigma, Sequence):
          self.gaussian_sigma = np.repeat(self.gaussian_sigma, ind_size)
        elif self.gaussian_sigma.shape[1] < size:
          raise IndexError("Gaussian variable of 'sigma' must be at least the size of individual: %d < %d" % (self.gaussian_sigma.shape[1], ind_size))
        for i, m, s in zip(xrange(ind_size), self.gaussian_mu, self.gaussian_sigma):
          if np.random.random() < self.gaussian_indep_prob:
              current_ind[1,i] += random.gauss(m, s)
        population[index,:] = current_ind
      return population
  



  def selection(self, population: np.array, fitness_values: np.array) -> np.array:
    if self.selection_func == "tournament":
      self.selection_size = int(np.round(self.population_size * self.selection_rate))
      new_generation = np.zeros((self.selection_size, self.individual_length))
      for i in range(self.selection_size):
	      selection_ix = np.random.randint(self.population_size)
	      for ix in np.random.randint(0, self.population_size, self.tournament_size-1):
      		if fitness_values[ix] > fitness_values[selection_ix]:
			      selection_ix = ix
	      new_generation[i,:] = population[selection_ix,:]
      return new_generation
  
  def visualization_parameters(self, population: np.array, fitness_values: np.array):
    selected_indv = pd.DataFrame()
    # best, worst, mean individual
    
  def override_line(text: str) -> None:
    """
    Helper function to replace the current output line of text.
    """
    # Hackish but works (tested on Linux only). Assumes there are
    # no more than 100 characters written in the current line.
    sys.stdout.write(f"\r{' ' * 100}\r{text}")
    sys.stdout.flush()

  def visualization(self, population: np.array):
    #plot the results
    population = population

  def fittest_individual(self, population: np.array, fit_value: np.array) -> np.array:
    # this function returns the fittest individual in each generation & be used to control the stall limits
    ind = np.where(fit_value == max(fit_value))
    ind = int(ind[0][0])
    fittest_ind = population[ind,:]
    fittest_and_fitness = np.append(fittest_ind, max(fit_value))
    return fittest_and_fitness

  # worst ind

  # avr ind
  
  def ga_memory(self, population: np.array):
    # use this is a dataframe used for saving the previous iteration to prevent recalculation of the same individuals
    population = population

  def run(self):
    """
    The main running code
    """
    start = time.time()

    if (self.crossover_func == "single-point" or self.crossover_func == "two-point" or self.crossover_func == "uniform") and self.ga_type != "binary":
      warnings.warn("%s crossover function is suggested with the binary-coded genetic algorithm" %(self.crossover_func))
    #if self.ga_type == "binary":
    #  raise Exception('%s crossover function cannot be used with binary-coded genetic algorithm structure' %(self.crossover_func))
    if int(np.round(self.population_size * self.selection_rate) + np.round(self.population_size * self.elitism_rate)) != self.population_size:
      warnings.warn("In order to create proper next population, crossover rate is increased to %s" %(self.selection_rate))
    # selection & elitism size warning'e özel bir if-else ekleyeceğiz - selection sayısını artıracak
    # ya da crossover rate girip selection rate'i kaldıralım, selection > population mantıklı mı?
    fittest_ind_array = np.zeros((self.gen_lim, self.population_size))

    population = self.in_pop()
    gen_number = 0
    stall_generation = 0
    fitness_values = self.fitness_value(population)
    fittest_ind = self.fittest_individual(population, fitness_values)
     
    best_score = fittest_ind[-1]

    if self.verbosa and self.population_size <= 25:
      print(f"Initial population: {population}")
    
    while stall_generation < self.termination_time and gen_number < self.gen_lim:
      
      population = self.gen_pop(population)
      gen_number += 1
      fitness_values = self.fitness_value(population)
      fittest_ind_current = self.fittest_individual(population, fitness_values)
      fittest_ind_array[gen_number,:] = fittest_ind_current[-1]
      if fittest_ind_current[-1] > best_score:
        stall_generation = 0
        fittest_ind = fittest_ind_current
        best_score = fittest_ind_current[-1]
        if self.verbosa:
            print(
                f"[Generation {gen_number:}] "
                f"Fittest individual: {fittest_ind} "
                f"(Best score {best_score})\n"
            )
      else:
        stall_generation += 1
        ind = np.where(fitness_values == min(fitness_values))
        ind = int(ind[0][0])
        sorted_index = np.argsort(self.fitness_value(population),axis=0)
        population[ind,:] = fittest_ind[0:-1]

        if self.verbosa:
            print(
                f"Generation {gen_number}: "
                f"Fittest individual: {fittest_ind} "
                f"(Best score {best_score} "
                f"elapsed time {(time.time() - start):2.2f}s)"
            )
        


    if self.verbosa:
        total_time = time.time() - start
        print(
            f"Fittest individual: {fittest_ind} "
            f"(Generation {gen_number}, "
            f"score: {best_score})\n"
        )
        print(f"Generations: {gen_number}")
        print(
            f"Elapsed time: {total_time:.2f}s "
            f"(avg {total_time / gen_number:.2}s)"
        )
    return fittest_ind, fittest_ind_array


ga = GeneticAlgorithm(population_size= 20, ga_type= 'binary', crossover_func ='two-point', individual_length= 100, fitness_function = fitness_function, termination_time = 10, gen_lim = 50,verbosa=True)
fittest_ind, fittest_ind_array = ga.run()
np.savetxt("fittest_ind.csv", fittest_ind_array, delimiter=",")